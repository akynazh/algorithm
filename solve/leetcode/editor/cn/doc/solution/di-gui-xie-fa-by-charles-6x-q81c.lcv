有点类似于根据中序遍历和前序遍历构造二叉树的题目，注意这里是二叉搜索树和后序遍历，后续遍历的特点就是遍历列表的最后一个值即为根节点，因此我们只需要不断判断根节点左右两边的值是否合法即可。

* 

```
class Solution {

    int [] postorder;
    public boolean verifyPostorder(int[] postorder) {
        this.postorder = postorder;
        return isOk(0,postorder.length-1);
    }

    public boolean isOk(int left,int right){
        //遍历post数组，发现第一个大于root的值，从这个值开始即为右子树，再观察右子树是否都合法
        if(left >= right) return true;
        int i;
        for(i = left;i < right;i++){
            if(postorder[i] > postorder[right]){
                break;
            }
        }
        for(int j = i;j < right;j++){
            if(postorder[j] < postorder[right]) return false;
        }
        return isOk(left,i - 1) && isOk(i,right - 1);
    }
}
```

