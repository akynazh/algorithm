此题解参考自[最简洁思路 & 5行代码](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/zui-jian-ji-si-lu-5xing-dai-ma-by-fool_d-6dpt/)，原题解很简洁，在此我做一些必要的说明和注释。

对于此题，我们可以先思考：

为什么 `0<=n<=9` 时，返回的就是 n，而当 `n=11` 时，返回的却是 0（如果返回的就是 11 那该多好！）

**原因很简单，因为 '10' 这个数字，占了两个字符位，所以会把 '11' 往后挤。**

我们也可以发现， 0<=n<=9 时，映射关系很直接。

但从十位数起，我们就很难确定映射关系，因为更往后的数字，被挤的更后了。

对此，我们可以让所有数字统一字符宽度，这样可以轻松地写出映射关系。

对于**原序列**：（做了分隔便于观察）

* js

```js
0|1|2|3|4|5|6|7|8|9|10
```

比如我们此时需要返回第11位数字为'0'，我们统一对 0-9 的这些个字符宽度也添补 0 变为两位数

**新序列**变为：

* js

```js
00|01|02|03|04|05|06|07|08|09|10
```

这样会**新增十个数位**，原本需要返回序列的第11位，在新序列中应该返回的是第21位 **（下标均从0开始）**

* js

```js
21 = 原位置 n + 新增数位 = 11+10
```

此时我们要返回该数字，直接返回 **新序列[21]** 即可。

---

但我们**不需要额外创建一个新序列**，这样太浪费空间，弄巧成拙！

针对上例，仔细数一下，我们可以**返回原序列的第 10 个隔间的第 1 个数字**，即 |10| 中的 '0'，**（下标均从0开始）**

而这些个虚拟隔间，正好是我们假想的**等宽字符**间隔而成，**我们怎么样变过去，就怎么样变回来**。所以对这个假想新序列的第 21 位数字，我们该如何还原成原本的答案？

**方法如下：**

1. 首先我们**应该找到它的虚拟隔间位置**，此例中按照每 `2` 数位一隔间，我们可以利用 `21 // 2` 得到，它在第 `10` 个隔间 **（下标均从0开始）**
2. 之后我们需要确定**它在隔间的位置**，很简单，**求余即可**，`21 % 2 = 1`

所以我们知道，在新序列中得到的新位置 `newN`， 除以 2 并向下取整可以得到一个数字隔间，再求得在隔间内对应数字的位置便可得到最终答案。

写成伪代码就是：

* js

```js
// 地板除
str(newN / i)[newN % i]
```

其中 `newN` 代表假想序列 `n` 的位置，`i` 代表间隔宽度。

实际代码如下：

* js

```js
var findNthDigit = function (n) {
    let i = 1
    // 如何判断间隔宽度，即每个数字新增多少个0？
    // 一位数的假想序列长度为10，二位数的假想序列为200（000102...9899），三位数3000以此类推，所以假想序列的长度为 i*10^i
    // 而实际的 n 应该落在这个假想序列的范围内。当 i*10^i < n 时，我们需要新增数位操作，来满足条件。
    
    while (i * Math.pow(10, i) < n) {
        // 新增数位导致 n 向后移
        n += Math.pow(10, i)
        i++
    }
    // 得出隔间数字，并转为字符
    const partition = Math.floor(n / i) + ""
    return partition.charAt(n % i)
};
```

